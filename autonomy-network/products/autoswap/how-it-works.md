# How It Works

Having limit orders and stop losses execute on a DEX works the same as any other [`Request`](https://app.gitbook.com/o/-MeA5RrsH6Q0j4yLUM7C/s/P3QZIVWdqKkHhz0tX5KC/) on Autonomy. Say the price of ETH is $1000 and the user wants to set a stop loss order to sell ETH when the price gets to $900:

1. The user makes a tx (the only tx that the user makes in the whole flow) which [creates a `Request`](https://github.com/Autonomy-Network/autonomy-contracts/blob/main/interfaces/IRegistry.sol#L76) on Autonomy that asks Autonomy to [call the limits/stops](https://github.com/Autonomy-Network/uniV2-limits-stops/blob/62def4a2a686fba8528ba3582278467e56b525c0/contracts/UniV2LimitsStops.sol#L110) contract. Initially this `Request` is impossible to execute, because the condition is [codified in a `require` statement](https://github.com/Autonomy-Network/uniV2-limits-stops/blob/62def4a2a686fba8528ba3582278467e56b525c0/contracts/UniV2LimitsStops.sol#L120) - any tx that tries to execute the `Request` will revert. This check is done on the actual input/output amounts of the trade, and is therefore a guarantee that the user will always get the trade they want, and doesn't need to rely on an oracle. The user still has their tokens in their wallet.
2. The price on the DEX drops to $900 as 3rd parties trade on it.
3. The Autonomy bots are constantly simulating whether executing a `Request` will succeed or revert. If they see it would succeed, that means that the condition for the trade is now true, and the `require` statement won't make the tx revert. This means the bot can know when a trade can be executed without knowing anything about tokens or prices or oracles. The bot now executes the `Request`, which atomically swaps the user's input token to the output token and it shows up in their wallet. At no point does the bot ever have control over the user's tokens.
